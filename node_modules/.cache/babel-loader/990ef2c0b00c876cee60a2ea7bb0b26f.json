{"ast":null,"code":"'use strict';\n\nvar firebase = require('@firebase/app');\nvar component = require('@firebase/component');\nvar tslib = require('tslib');\nvar util = require('@firebase/util');\nvar logger$1 = require('@firebase/logger');\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\nvar firebase__default = /*#__PURE__*/_interopDefaultLegacy(firebase);\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nvar _a;\nvar ERRORS = (_a = {}, _a[\"already-activated\" /* ALREADY_ACTIVATED */] = 'You are trying to activate AppCheck for FirebaseApp {$appName}, ' + 'while it is already activated. ' + 'AppCheck can only be activated once.', _a[\"use-before-activation\" /* USE_BEFORE_ACTIVATION */] = 'AppCheck is being used before activate() is called for FirebaseApp {$appName}. ' + 'Please make sure you call activate() before instantiating other Firebase services.', _a[\"fetch-network-error\" /* FETCH_NETWORK_ERROR */] = 'Fetch failed to connect to a network. Check Internet connection. ' + 'Original error: {$originalErrorMessage}.', _a[\"fetch-parse-error\" /* FETCH_PARSE_ERROR */] = 'Fetch client could not parse response.' + ' Original error: {$originalErrorMessage}.', _a[\"fetch-status-error\" /* FETCH_STATUS_ERROR */] = 'Fetch server returned an HTTP error status. HTTP status: {$httpStatus}.', _a[\"storage-open\" /* STORAGE_OPEN */] = 'Error thrown when opening storage. Original error: {$originalErrorMessage}.', _a[\"storage-get\" /* STORAGE_GET */] = 'Error thrown when reading from storage. Original error: {$originalErrorMessage}.', _a[\"storage-set\" /* STORAGE_WRITE */] = 'Error thrown when writing to storage. Original error: {$originalErrorMessage}.', _a[\"recaptcha-error\" /* RECAPTCHA_ERROR */] = 'ReCAPTCHA error.', _a);\nvar ERROR_FACTORY = new util.ErrorFactory('appCheck', 'AppCheck', ERRORS);\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nvar APP_CHECK_STATES = new Map();\nvar DEFAULT_STATE = {\n  activated: false,\n  tokenObservers: []\n};\nvar DEBUG_STATE = {\n  enabled: false\n};\nfunction getState(app) {\n  return APP_CHECK_STATES.get(app) || DEFAULT_STATE;\n}\nfunction setState(app, state) {\n  APP_CHECK_STATES.set(app, state);\n}\nfunction getDebugState() {\n  return DEBUG_STATE;\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nfunction getRecaptcha() {\n  return self.grecaptcha;\n}\nfunction ensureActivated(app) {\n  if (!getState(app).activated) {\n    throw ERROR_FACTORY.create(\"use-before-activation\" /* USE_BEFORE_ACTIVATION */, {\n      appName: app.name\n    });\n  }\n}\n/**\r\n * Copied from https://stackoverflow.com/a/2117523\r\n */\nfunction uuidv4() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    var r = Math.random() * 16 | 0,\n      v = c === 'x' ? r : r & 0x3 | 0x8;\n    return v.toString(16);\n  });\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nvar RECAPTCHA_URL = 'https://www.google.com/recaptcha/api.js';\nfunction initialize(app, siteKey) {\n  var state = getState(app);\n  var initialized = new util.Deferred();\n  setState(app, tslib.__assign(tslib.__assign({}, state), {\n    reCAPTCHAState: {\n      initialized: initialized\n    }\n  }));\n  var divId = \"fire_app_check_\" + app.name;\n  var invisibleDiv = document.createElement('div');\n  invisibleDiv.id = divId;\n  invisibleDiv.style.display = 'none';\n  document.body.appendChild(invisibleDiv);\n  var grecaptcha = getRecaptcha();\n  if (!grecaptcha) {\n    loadReCAPTCHAScript(function () {\n      var grecaptcha = getRecaptcha();\n      if (!grecaptcha) {\n        // it shouldn't happen.\n        throw new Error('no recaptcha');\n      }\n      grecaptcha.ready(function () {\n        // Invisible widgets allow us to set a different siteKey for each widget, so we use them to support multiple apps\n        renderInvisibleWidget(app, siteKey, grecaptcha, divId);\n        initialized.resolve(grecaptcha);\n      });\n    });\n  } else {\n    grecaptcha.ready(function () {\n      renderInvisibleWidget(app, siteKey, grecaptcha, divId);\n      initialized.resolve(grecaptcha);\n    });\n  }\n  return initialized.promise;\n}\nfunction getToken$2(app) {\n  return tslib.__awaiter(this, void 0, void 0, function () {\n    var reCAPTCHAState, recaptcha;\n    return tslib.__generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          ensureActivated(app);\n          reCAPTCHAState = getState(app).reCAPTCHAState;\n          return [4 /*yield*/, reCAPTCHAState.initialized.promise];\n        case 1:\n          recaptcha = _a.sent();\n          return [2 /*return*/, new Promise(function (resolve, _reject) {\n            // Updated after initialization is complete.\n            var reCAPTCHAState = getState(app).reCAPTCHAState;\n            recaptcha.ready(function () {\n              resolve(\n              // widgetId is guaranteed to be available if reCAPTCHAState.initialized.promise resolved.\n              recaptcha.execute(reCAPTCHAState.widgetId, {\n                action: 'fire_app_check'\n              }));\n            });\n          })];\n      }\n    });\n  });\n}\n/**\r\n *\r\n * @param app\r\n * @param container - Id of a HTML element.\r\n */\nfunction renderInvisibleWidget(app, siteKey, grecaptcha, container) {\n  var widgetId = grecaptcha.render(container, {\n    sitekey: siteKey,\n    size: 'invisible'\n  });\n  var state = getState(app);\n  setState(app, tslib.__assign(tslib.__assign({}, state), {\n    reCAPTCHAState: tslib.__assign(tslib.__assign({}, state.reCAPTCHAState), {\n      // state.reCAPTCHAState is set in the initialize()\n      widgetId: widgetId\n    })\n  }));\n}\nfunction loadReCAPTCHAScript(onload) {\n  var script = document.createElement('script');\n  script.src = \"\" + RECAPTCHA_URL;\n  script.onload = onload;\n  document.head.appendChild(script);\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nvar BASE_ENDPOINT = 'https://content-firebaseappcheck.googleapis.com/v1beta';\nvar EXCHANGE_RECAPTCHA_TOKEN_METHOD = 'exchangeRecaptchaToken';\nvar EXCHANGE_DEBUG_TOKEN_METHOD = 'exchangeDebugToken';\nvar TOKEN_REFRESH_TIME = {\n  /**\r\n   * The offset time before token natural expiration to run the refresh.\r\n   * This is currently 5 minutes.\r\n   */\n  OFFSET_DURATION: 5 * 60 * 1000,\n  /**\r\n   * This is the first retrial wait after an error. This is currently\r\n   * 30 seconds.\r\n   */\n  RETRIAL_MIN_WAIT: 30 * 1000,\n  /**\r\n   * This is the maximum retrial wait, currently 16 minutes.\r\n   */\n  RETRIAL_MAX_WAIT: 16 * 60 * 1000\n};\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n/**\r\n * Port from auth proactiverefresh.js\r\n *\r\n */\n// TODO: move it to @firebase/util?\n// TODO: allow to config whether refresh should happen in the background\nvar Refresher = /** @class */function () {\n  function Refresher(operation, retryPolicy, getWaitDuration, lowerBound, upperBound) {\n    this.operation = operation;\n    this.retryPolicy = retryPolicy;\n    this.getWaitDuration = getWaitDuration;\n    this.lowerBound = lowerBound;\n    this.upperBound = upperBound;\n    this.pending = null;\n    this.nextErrorWaitInterval = lowerBound;\n    if (lowerBound > upperBound) {\n      throw new Error('Proactive refresh lower bound greater than upper bound!');\n    }\n  }\n  Refresher.prototype.start = function () {\n    this.nextErrorWaitInterval = this.lowerBound;\n    this.process(true).catch(function () {\n      /* we don't care about the result */\n    });\n  };\n  Refresher.prototype.stop = function () {\n    if (this.pending) {\n      this.pending.reject('cancelled');\n      this.pending = null;\n    }\n  };\n  Refresher.prototype.isRunning = function () {\n    return !!this.pending;\n  };\n  Refresher.prototype.process = function (hasSucceeded) {\n    return tslib.__awaiter(this, void 0, void 0, function () {\n      var error_1;\n      return tslib.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.stop();\n            _a.label = 1;\n          case 1:\n            _a.trys.push([1, 6,, 7]);\n            this.pending = new util.Deferred();\n            return [4 /*yield*/, sleep(this.getNextRun(hasSucceeded))];\n          case 2:\n            _a.sent();\n            // Why do we resolve a promise, then immediate wait for it?\n            // We do it to make the promise chain cancellable.\n            // We can call stop() which rejects the promise before the following line execute, which makes\n            // the code jump to the catch block.\n            // TODO: unit test this\n            this.pending.resolve();\n            return [4 /*yield*/, this.pending.promise];\n          case 3:\n            _a.sent();\n            this.pending = new util.Deferred();\n            return [4 /*yield*/, this.operation()];\n          case 4:\n            _a.sent();\n            this.pending.resolve();\n            return [4 /*yield*/, this.pending.promise];\n          case 5:\n            _a.sent();\n            this.process(true).catch(function () {\n              /* we don't care about the result */\n            });\n            return [3 /*break*/, 7];\n          case 6:\n            error_1 = _a.sent();\n            if (this.retryPolicy(error_1)) {\n              this.process(false).catch(function () {\n                /* we don't care about the result */\n              });\n            } else {\n              this.stop();\n            }\n            return [3 /*break*/, 7];\n          case 7:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  Refresher.prototype.getNextRun = function (hasSucceeded) {\n    if (hasSucceeded) {\n      // If last operation succeeded, reset next error wait interval and return\n      // the default wait duration.\n      this.nextErrorWaitInterval = this.lowerBound;\n      // Return typical wait duration interval after a successful operation.\n      return this.getWaitDuration();\n    } else {\n      // Get next error wait interval.\n      var currentErrorWaitInterval = this.nextErrorWaitInterval;\n      // Double interval for next consecutive error.\n      this.nextErrorWaitInterval *= 2;\n      // Make sure next wait interval does not exceed the maximum upper bound.\n      if (this.nextErrorWaitInterval > this.upperBound) {\n        this.nextErrorWaitInterval = this.upperBound;\n      }\n      return currentErrorWaitInterval;\n    }\n  };\n  return Refresher;\n}();\nfunction sleep(ms) {\n  return new Promise(function (resolve) {\n    setTimeout(resolve, ms);\n  });\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nfunction exchangeToken(_a, platformLoggerProvider) {\n  var url = _a.url,\n    body = _a.body;\n  return tslib.__awaiter(this, void 0, void 0, function () {\n    var headers, platformLogger, options, response, originalError_1, responseBody, originalError_2, match, timeToLiveAsNumber, now;\n    return tslib.__generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          headers = {\n            'Content-Type': 'application/json'\n          };\n          platformLogger = platformLoggerProvider.getImmediate({\n            optional: true\n          });\n          if (platformLogger) {\n            headers['X-Firebase-Client'] = platformLogger.getPlatformInfoString();\n          }\n          options = {\n            method: 'POST',\n            body: JSON.stringify(body),\n            headers: headers\n          };\n          _b.label = 1;\n        case 1:\n          _b.trys.push([1, 3,, 4]);\n          return [4 /*yield*/, fetch(url, options)];\n        case 2:\n          response = _b.sent();\n          return [3 /*break*/, 4];\n        case 3:\n          originalError_1 = _b.sent();\n          throw ERROR_FACTORY.create(\"fetch-network-error\" /* FETCH_NETWORK_ERROR */, {\n            originalErrorMessage: originalError_1.message\n          });\n        case 4:\n          if (response.status !== 200) {\n            throw ERROR_FACTORY.create(\"fetch-status-error\" /* FETCH_STATUS_ERROR */, {\n              httpStatus: response.status\n            });\n          }\n          _b.label = 5;\n        case 5:\n          _b.trys.push([5, 7,, 8]);\n          return [4 /*yield*/, response.json()];\n        case 6:\n          // JSON parsing throws SyntaxError if the response body isn't a JSON string.\n          responseBody = _b.sent();\n          return [3 /*break*/, 8];\n        case 7:\n          originalError_2 = _b.sent();\n          throw ERROR_FACTORY.create(\"fetch-parse-error\" /* FETCH_PARSE_ERROR */, {\n            originalErrorMessage: originalError_2.message\n          });\n        case 8:\n          match = responseBody.ttl.match(/^([\\d.]+)(s)$/);\n          if (!match || !match[2] || isNaN(Number(match[1]))) {\n            throw ERROR_FACTORY.create(\"fetch-parse-error\" /* FETCH_PARSE_ERROR */, {\n              originalErrorMessage: \"ttl field (timeToLive) is not in standard Protobuf Duration \" + (\"format: \" + responseBody.ttl)\n            });\n          }\n          timeToLiveAsNumber = Number(match[1]) * 1000;\n          now = Date.now();\n          return [2 /*return*/, {\n            token: responseBody.attestationToken,\n            expireTimeMillis: now + timeToLiveAsNumber,\n            issuedAtTimeMillis: now\n          }];\n      }\n    });\n  });\n}\nfunction getExchangeRecaptchaTokenRequest(app, reCAPTCHAToken) {\n  var _a = app.options,\n    projectId = _a.projectId,\n    appId = _a.appId,\n    apiKey = _a.apiKey;\n  return {\n    url: BASE_ENDPOINT + \"/projects/\" + projectId + \"/apps/\" + appId + \":\" + EXCHANGE_RECAPTCHA_TOKEN_METHOD + \"?key=\" + apiKey,\n    body: {\n      // eslint-disable-next-line\n      recaptcha_token: reCAPTCHAToken\n    }\n  };\n}\nfunction getExchangeDebugTokenRequest(app, debugToken) {\n  var _a = app.options,\n    projectId = _a.projectId,\n    appId = _a.appId,\n    apiKey = _a.apiKey;\n  return {\n    url: BASE_ENDPOINT + \"/projects/\" + projectId + \"/apps/\" + appId + \":\" + EXCHANGE_DEBUG_TOKEN_METHOD + \"?key=\" + apiKey,\n    body: {\n      // eslint-disable-next-line\n      debug_token: debugToken\n    }\n  };\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nvar DB_NAME = 'firebase-app-check-database';\nvar DB_VERSION = 1;\nvar STORE_NAME = 'firebase-app-check-store';\nvar DEBUG_TOKEN_KEY = 'debug-token';\nvar dbPromise = null;\nfunction getDBPromise() {\n  if (dbPromise) {\n    return dbPromise;\n  }\n  dbPromise = new Promise(function (resolve, reject) {\n    try {\n      var request = indexedDB.open(DB_NAME, DB_VERSION);\n      request.onsuccess = function (event) {\n        resolve(event.target.result);\n      };\n      request.onerror = function (event) {\n        var _a;\n        reject(ERROR_FACTORY.create(\"storage-open\" /* STORAGE_OPEN */, {\n          originalErrorMessage: (_a = event.target.error) === null || _a === void 0 ? void 0 : _a.message\n        }));\n      };\n      request.onupgradeneeded = function (event) {\n        var db = event.target.result;\n        // We don't use 'break' in this switch statement, the fall-through\n        // behavior is what we want, because if there are multiple versions between\n        // the old version and the current version, we want ALL the migrations\n        // that correspond to those versions to run, not only the last one.\n        // eslint-disable-next-line default-case\n        switch (event.oldVersion) {\n          case 0:\n            db.createObjectStore(STORE_NAME, {\n              keyPath: 'compositeKey'\n            });\n        }\n      };\n    } catch (e) {\n      reject(ERROR_FACTORY.create(\"storage-open\" /* STORAGE_OPEN */, {\n        originalErrorMessage: e.message\n      }));\n    }\n  });\n  return dbPromise;\n}\nfunction readTokenFromIndexedDB(app) {\n  return read(computeKey(app));\n}\nfunction writeTokenToIndexedDB(app, token) {\n  return write(computeKey(app), token);\n}\nfunction writeDebugTokenToIndexedDB(token) {\n  return write(DEBUG_TOKEN_KEY, token);\n}\nfunction readDebugTokenFromIndexedDB() {\n  return read(DEBUG_TOKEN_KEY);\n}\nfunction write(key, value) {\n  return tslib.__awaiter(this, void 0, void 0, function () {\n    var db, transaction, store, request;\n    return tslib.__generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4 /*yield*/, getDBPromise()];\n        case 1:\n          db = _a.sent();\n          transaction = db.transaction(STORE_NAME, 'readwrite');\n          store = transaction.objectStore(STORE_NAME);\n          request = store.put({\n            compositeKey: key,\n            value: value\n          });\n          return [2 /*return*/, new Promise(function (resolve, reject) {\n            request.onsuccess = function (_event) {\n              resolve();\n            };\n            transaction.onerror = function (event) {\n              var _a;\n              reject(ERROR_FACTORY.create(\"storage-set\" /* STORAGE_WRITE */, {\n                originalErrorMessage: (_a = event.target.error) === null || _a === void 0 ? void 0 : _a.message\n              }));\n            };\n          })];\n      }\n    });\n  });\n}\nfunction read(key) {\n  return tslib.__awaiter(this, void 0, void 0, function () {\n    var db, transaction, store, request;\n    return tslib.__generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4 /*yield*/, getDBPromise()];\n        case 1:\n          db = _a.sent();\n          transaction = db.transaction(STORE_NAME, 'readonly');\n          store = transaction.objectStore(STORE_NAME);\n          request = store.get(key);\n          return [2 /*return*/, new Promise(function (resolve, reject) {\n            request.onsuccess = function (event) {\n              var result = event.target.result;\n              if (result) {\n                resolve(result.value);\n              } else {\n                resolve(undefined);\n              }\n            };\n            transaction.onerror = function (event) {\n              var _a;\n              reject(ERROR_FACTORY.create(\"storage-get\" /* STORAGE_GET */, {\n                originalErrorMessage: (_a = event.target.error) === null || _a === void 0 ? void 0 : _a.message\n              }));\n            };\n          })];\n      }\n    });\n  });\n}\nfunction computeKey(app) {\n  return app.options.appId + \"-\" + app.name;\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nvar logger = new logger$1.Logger('@firebase/app-check');\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n/**\r\n * Always resolves. In case of an error reading from indexeddb, resolve with undefined\r\n */\nfunction readTokenFromStorage(app) {\n  return tslib.__awaiter(this, void 0, void 0, function () {\n    var token, e_1;\n    return tslib.__generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          if (!util.isIndexedDBAvailable()) return [3 /*break*/, 5];\n          token = undefined;\n          _a.label = 1;\n        case 1:\n          _a.trys.push([1, 3,, 4]);\n          return [4 /*yield*/, readTokenFromIndexedDB(app)];\n        case 2:\n          token = _a.sent();\n          return [3 /*break*/, 4];\n        case 3:\n          e_1 = _a.sent();\n          // swallow the error and return undefined\n          logger.warn(\"Failed to read token from indexeddb. Error: \" + e_1);\n          return [3 /*break*/, 4];\n        case 4:\n          return [2 /*return*/, token];\n        case 5:\n          return [2 /*return*/, undefined];\n      }\n    });\n  });\n}\n/**\r\n * Always resolves. In case of an error writing to indexeddb, print a warning and resolve the promise\r\n */\nfunction writeTokenToStorage(app, token) {\n  if (util.isIndexedDBAvailable()) {\n    return writeTokenToIndexedDB(app, token).catch(function (e) {\n      // swallow the error and resolve the promise\n      logger.warn(\"Failed to write token to indexeddb. Error: \" + e);\n    });\n  }\n  return Promise.resolve();\n}\nfunction readOrCreateDebugTokenFromStorage() {\n  return tslib.__awaiter(this, void 0, void 0, function () {\n    var existingDebugToken, newToken;\n    return tslib.__generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          existingDebugToken = undefined;\n          _a.label = 1;\n        case 1:\n          _a.trys.push([1, 3,, 4]);\n          return [4 /*yield*/, readDebugTokenFromIndexedDB()];\n        case 2:\n          existingDebugToken = _a.sent();\n          return [3 /*break*/, 4];\n        case 3:\n          _a.sent();\n          return [3 /*break*/, 4];\n        case 4:\n          if (!existingDebugToken) {\n            newToken = uuidv4();\n            // We don't need to block on writing to indexeddb\n            // In case persistence failed, a new debug token will be generated everytime the page is refreshed.\n            // It renders the debug token useless because you have to manually register(whitelist) the new token in the firebase console again and again.\n            // If you see this error trying to use debug token, it probably means you are using a browser that doesn't support indexeddb.\n            // You should switch to a different browser that supports indexeddb\n            writeDebugTokenToIndexedDB(newToken).catch(function (e) {\n              return logger.warn(\"Failed to persist debug token to indexeddb. Error: \" + e);\n            });\n            // Not using logger because I don't think we ever want this accidentally hidden?\n            console.log(\"AppCheck debug token: \" + newToken + \". You will need to whitelist it in the Firebase console for it to work\");\n            return [2 /*return*/, newToken];\n          } else {\n            return [2 /*return*/, existingDebugToken];\n          }\n      }\n    });\n  });\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nfunction isDebugMode() {\n  var debugState = getDebugState();\n  return debugState.enabled;\n}\nfunction getDebugToken() {\n  return tslib.__awaiter(this, void 0, void 0, function () {\n    var state;\n    return tslib.__generator(this, function (_a) {\n      state = getDebugState();\n      if (state.enabled && state.token) {\n        return [2 /*return*/, state.token.promise];\n      } else {\n        // should not happen!\n        throw Error(\"\\n            Can't get debug token in production mode.\\n        \");\n      }\n    });\n  });\n}\nfunction initializeDebugMode() {\n  var globals = util.getGlobal();\n  if (typeof globals.FIREBASE_APPCHECK_DEBUG_TOKEN !== 'string' && globals.FIREBASE_APPCHECK_DEBUG_TOKEN !== true) {\n    return;\n  }\n  var debugState = getDebugState();\n  debugState.enabled = true;\n  var deferredToken = new util.Deferred();\n  debugState.token = deferredToken;\n  if (typeof globals.FIREBASE_APPCHECK_DEBUG_TOKEN === 'string') {\n    deferredToken.resolve(globals.FIREBASE_APPCHECK_DEBUG_TOKEN);\n  } else {\n    deferredToken.resolve(readOrCreateDebugTokenFromStorage());\n  }\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n// Initial hardcoded value agreed upon across platforms for initial launch.\n// Format left open for possible dynamic error values and other fields in the future.\nvar defaultTokenErrorData = {\n  error: 'UNKNOWN_ERROR'\n};\n/**\r\n * Stringify and base64 encode token error data.\r\n *\r\n * @param tokenError Error data, currently hardcoded.\r\n */\nfunction formatDummyToken(tokenErrorData) {\n  return util.base64.encodeString(JSON.stringify(tokenErrorData), /* webSafe= */false);\n}\n/**\r\n * This function will always resolve.\r\n * The result will contain an error field if there is any error.\r\n * In case there is an error, the token field in the result will be populated with a dummy value\r\n */\nfunction getToken$1(app, platformLoggerProvider, forceRefresh) {\n  if (forceRefresh === void 0) {\n    forceRefresh = false;\n  }\n  return tslib.__awaiter(this, void 0, void 0, function () {\n    var state, token, error, cachedToken, tokenFromDebugExchange, _a, _b, _c, customToken, issuedAtTimeSeconds, issuedAtTimeMillis, attestedClaimsToken, e_1, interopTokenResult;\n    return tslib.__generator(this, function (_d) {\n      switch (_d.label) {\n        case 0:\n          ensureActivated(app);\n          state = getState(app);\n          token = state.token;\n          error = undefined;\n          if (!!token) return [3 /*break*/, 2];\n          return [4 /*yield*/, readTokenFromStorage(app)];\n        case 1:\n          cachedToken = _d.sent();\n          if (cachedToken && isValid(cachedToken)) {\n            token = cachedToken;\n            setState(app, tslib.__assign(tslib.__assign({}, state), {\n              token: token\n            }));\n            // notify all listeners with the cached token\n            notifyTokenListeners(app, {\n              token: token.token\n            });\n          }\n          _d.label = 2;\n        case 2:\n          // Return the cached token (from either memory or indexedDB) if it's valid\n          if (!forceRefresh && token && isValid(token)) {\n            return [2 /*return*/, {\n              token: token.token\n            }];\n          }\n          if (!isDebugMode()) return [3 /*break*/, 6];\n          _a = exchangeToken;\n          _b = getExchangeDebugTokenRequest;\n          _c = [app];\n          return [4 /*yield*/, getDebugToken()];\n        case 3:\n          return [4 /*yield*/, _a.apply(void 0, [_b.apply(void 0, _c.concat([_d.sent()])), platformLoggerProvider])];\n        case 4:\n          tokenFromDebugExchange = _d.sent();\n          // Write debug token to indexedDB.\n          return [4 /*yield*/, writeTokenToStorage(app, tokenFromDebugExchange)];\n        case 5:\n          // Write debug token to indexedDB.\n          _d.sent();\n          // Write debug token to state.\n          setState(app, tslib.__assign(tslib.__assign({}, state), {\n            token: tokenFromDebugExchange\n          }));\n          return [2 /*return*/, {\n            token: tokenFromDebugExchange.token\n          }];\n        case 6:\n          _d.trys.push([6, 12,, 13]);\n          if (!state.customProvider) return [3 /*break*/, 8];\n          return [4 /*yield*/, state.customProvider.getToken()];\n        case 7:\n          customToken = _d.sent();\n          issuedAtTimeSeconds = util.issuedAtTime(customToken.token);\n          issuedAtTimeMillis = issuedAtTimeSeconds !== null && issuedAtTimeSeconds < Date.now() && issuedAtTimeSeconds > 0 ? issuedAtTimeSeconds * 1000 : Date.now();\n          token = tslib.__assign(tslib.__assign({}, customToken), {\n            issuedAtTimeMillis: issuedAtTimeMillis\n          });\n          return [3 /*break*/, 11];\n        case 8:\n          return [4 /*yield*/, getToken$2(app).catch(function (_e) {\n            // reCaptcha.execute() throws null which is not very descriptive.\n            throw ERROR_FACTORY.create(\"recaptcha-error\" /* RECAPTCHA_ERROR */);\n          })];\n        case 9:\n          attestedClaimsToken = _d.sent();\n          return [4 /*yield*/, exchangeToken(getExchangeRecaptchaTokenRequest(app, attestedClaimsToken), platformLoggerProvider)];\n        case 10:\n          token = _d.sent();\n          _d.label = 11;\n        case 11:\n          return [3 /*break*/, 13];\n        case 12:\n          e_1 = _d.sent();\n          // `getToken()` should never throw, but logging error text to console will aid debugging.\n          logger.error(e_1);\n          error = e_1;\n          return [3 /*break*/, 13];\n        case 13:\n          if (!!token) return [3 /*break*/, 14];\n          // if token is undefined, there must be an error.\n          // we return a dummy token along with the error\n          interopTokenResult = makeDummyTokenResult(error);\n          return [3 /*break*/, 16];\n        case 14:\n          interopTokenResult = {\n            token: token.token\n          };\n          // write the new token to the memory state as well as the persistent storage.\n          // Only do it if we got a valid new token\n          setState(app, tslib.__assign(tslib.__assign({}, state), {\n            token: token\n          }));\n          return [4 /*yield*/, writeTokenToStorage(app, token)];\n        case 15:\n          _d.sent();\n          _d.label = 16;\n        case 16:\n          notifyTokenListeners(app, interopTokenResult);\n          return [2 /*return*/, interopTokenResult];\n      }\n    });\n  });\n}\nfunction addTokenListener(app, platformLoggerProvider, type, listener, onError) {\n  var state = getState(app);\n  var tokenListener = {\n    next: listener,\n    error: onError,\n    type: type\n  };\n  var newState = tslib.__assign(tslib.__assign({}, state), {\n    tokenObservers: tslib.__spreadArray(tslib.__spreadArray([], state.tokenObservers), [tokenListener])\n  });\n  /**\r\n   * Invoke the listener with the valid token, then start the token refresher\r\n   */\n  if (!newState.tokenRefresher) {\n    var tokenRefresher = createTokenRefresher(app, platformLoggerProvider);\n    newState.tokenRefresher = tokenRefresher;\n  }\n  // Create the refresher but don't start it if `isTokenAutoRefreshEnabled`\n  // is not true.\n  if (!newState.tokenRefresher.isRunning() && state.isTokenAutoRefreshEnabled === true) {\n    newState.tokenRefresher.start();\n  }\n  // invoke the listener async immediately if there is a valid token\n  if (state.token && isValid(state.token)) {\n    var validToken_1 = state.token;\n    Promise.resolve().then(function () {\n      return listener({\n        token: validToken_1.token\n      });\n    }).catch(function () {\n      /** Ignore errors in listeners. */\n    });\n  }\n  setState(app, newState);\n}\nfunction removeTokenListener(app, listener) {\n  var state = getState(app);\n  var newObservers = state.tokenObservers.filter(function (tokenObserver) {\n    return tokenObserver.next !== listener;\n  });\n  if (newObservers.length === 0 && state.tokenRefresher && state.tokenRefresher.isRunning()) {\n    state.tokenRefresher.stop();\n  }\n  setState(app, tslib.__assign(tslib.__assign({}, state), {\n    tokenObservers: newObservers\n  }));\n}\nfunction createTokenRefresher(app, platformLoggerProvider) {\n  var _this = this;\n  return new Refresher(\n  // Keep in mind when this fails for any reason other than the ones\n  // for which we should retry, it will effectively stop the proactive refresh.\n  function () {\n    return tslib.__awaiter(_this, void 0, void 0, function () {\n      var state, result;\n      return tslib.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            state = getState(app);\n            if (!!state.token) return [3 /*break*/, 2];\n            return [4 /*yield*/, getToken$1(app, platformLoggerProvider)];\n          case 1:\n            result = _a.sent();\n            return [3 /*break*/, 4];\n          case 2:\n            return [4 /*yield*/, getToken$1(app, platformLoggerProvider, true)];\n          case 3:\n            result = _a.sent();\n            _a.label = 4;\n          case 4:\n            // getToken() always resolves. In case the result has an error field defined, it means the operation failed, and we should retry.\n            if (result.error) {\n              throw result.error;\n            }\n            return [2 /*return*/];\n        }\n      });\n    });\n  }, function () {\n    // TODO: when should we retry?\n    return true;\n  }, function () {\n    var state = getState(app);\n    if (state.token) {\n      // issuedAtTime + (50% * total TTL) + 5 minutes\n      var nextRefreshTimeMillis = state.token.issuedAtTimeMillis + (state.token.expireTimeMillis - state.token.issuedAtTimeMillis) * 0.5 + 5 * 60 * 1000;\n      // Do not allow refresh time to be past (expireTime - 5 minutes)\n      var latestAllowableRefresh = state.token.expireTimeMillis - 5 * 60 * 1000;\n      nextRefreshTimeMillis = Math.min(nextRefreshTimeMillis, latestAllowableRefresh);\n      return Math.max(0, nextRefreshTimeMillis - Date.now());\n    } else {\n      return 0;\n    }\n  }, TOKEN_REFRESH_TIME.RETRIAL_MIN_WAIT, TOKEN_REFRESH_TIME.RETRIAL_MAX_WAIT);\n}\nfunction notifyTokenListeners(app, token) {\n  var observers = getState(app).tokenObservers;\n  for (var _i = 0, observers_1 = observers; _i < observers_1.length; _i++) {\n    var observer = observers_1[_i];\n    try {\n      if (observer.type === \"EXTERNAL\" /* EXTERNAL */ && token.error != null) {\n        // If this listener was added by a 3P call, send any token error to\n        // the supplied error handler. A 3P observer always has an error\n        // handler.\n        observer.error(token.error);\n      } else {\n        // If the token has no error field, always return the token.\n        // If this is a 2P listener, return the token, whether or not it\n        // has an error field.\n        observer.next(token);\n      }\n    } catch (ignored) {\n      // Errors in the listener function itself are always ignored.\n    }\n  }\n}\nfunction isValid(token) {\n  return token.expireTimeMillis - Date.now() > 0;\n}\nfunction makeDummyTokenResult(error) {\n  return {\n    token: formatDummyToken(defaultTokenErrorData),\n    error: error\n  };\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n/**\r\n *\r\n * @param app\r\n * @param siteKeyOrProvider - optional custom attestation provider\r\n * or reCAPTCHA siteKey\r\n * @param isTokenAutoRefreshEnabled - if true, enables auto refresh\r\n * of appCheck token.\r\n */\nfunction activate(app, siteKeyOrProvider, isTokenAutoRefreshEnabled) {\n  var state = getState(app);\n  if (state.activated) {\n    throw ERROR_FACTORY.create(\"already-activated\" /* ALREADY_ACTIVATED */, {\n      appName: app.name\n    });\n  }\n  var newState = tslib.__assign(tslib.__assign({}, state), {\n    activated: true\n  });\n  if (typeof siteKeyOrProvider === 'string') {\n    newState.siteKey = siteKeyOrProvider;\n  } else {\n    newState.customProvider = siteKeyOrProvider;\n  }\n  // Use value of global `automaticDataCollectionEnabled` (which\n  // itself defaults to false if not specified in config) if\n  // `isTokenAutoRefreshEnabled` param was not provided by user.\n  newState.isTokenAutoRefreshEnabled = isTokenAutoRefreshEnabled === undefined ? app.automaticDataCollectionEnabled : isTokenAutoRefreshEnabled;\n  setState(app, newState);\n  // initialize reCAPTCHA if siteKey is provided\n  if (newState.siteKey) {\n    initialize(app, newState.siteKey).catch(function () {\n      /* we don't care about the initialization result in activate() */\n    });\n  }\n}\nfunction setTokenAutoRefreshEnabled(app, isTokenAutoRefreshEnabled) {\n  var state = getState(app);\n  // This will exist if any product libraries have called\n  // `addTokenListener()`\n  if (state.tokenRefresher) {\n    if (isTokenAutoRefreshEnabled === true) {\n      state.tokenRefresher.start();\n    } else {\n      state.tokenRefresher.stop();\n    }\n  }\n  setState(app, tslib.__assign(tslib.__assign({}, state), {\n    isTokenAutoRefreshEnabled: isTokenAutoRefreshEnabled\n  }));\n}\n/**\r\n * Differs from internal getToken in that it throws the error.\r\n */\nfunction getToken(app, platformLoggerProvider, forceRefresh) {\n  return tslib.__awaiter(this, void 0, void 0, function () {\n    var result;\n    return tslib.__generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4 /*yield*/, getToken$1(app, platformLoggerProvider, forceRefresh)];\n        case 1:\n          result = _a.sent();\n          if (result.error) {\n            throw result.error;\n          }\n          return [2 /*return*/, {\n            token: result.token\n          }];\n      }\n    });\n  });\n}\nfunction onTokenChanged(app, platformLoggerProvider, onNextOrObserver, onError,\n/**\r\n * NOTE: Although an `onCompletion` callback can be provided, it will\r\n * never be called because the token stream is never-ending.\r\n * It is added only for API consistency with the observer pattern, which\r\n * we follow in JS APIs.\r\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nonCompletion) {\n  var nextFn = function () {};\n  var errorFn = function () {};\n  if (onNextOrObserver.next != null) {\n    nextFn = onNextOrObserver.next.bind(onNextOrObserver);\n  } else {\n    nextFn = onNextOrObserver;\n  }\n  if (onNextOrObserver.error != null) {\n    errorFn = onNextOrObserver.error.bind(onNextOrObserver);\n  } else if (onError) {\n    errorFn = onError;\n  }\n  addTokenListener(app, platformLoggerProvider, \"EXTERNAL\" /* EXTERNAL */, nextFn, errorFn);\n  return function () {\n    return removeTokenListener(app, nextFn);\n  };\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nfunction factory(app, platformLoggerProvider) {\n  return {\n    app: app,\n    activate: function (siteKeyOrProvider, isTokenAutoRefreshEnabled) {\n      return activate(app, siteKeyOrProvider, isTokenAutoRefreshEnabled);\n    },\n    setTokenAutoRefreshEnabled: function (isTokenAutoRefreshEnabled) {\n      return setTokenAutoRefreshEnabled(app, isTokenAutoRefreshEnabled);\n    },\n    getToken: function (forceRefresh) {\n      return getToken(app, platformLoggerProvider, forceRefresh);\n    },\n    onTokenChanged: function (onNextOrObserver, onError, onCompletion) {\n      return onTokenChanged(app, platformLoggerProvider,\n      /**\r\n       * This can still be an observer. Need to do this casting because\r\n       * according to Typescript: \"Implementation signatures of overloads\r\n       * are not externally visible\"\r\n       */\n      onNextOrObserver, onError);\n    },\n    INTERNAL: {\n      delete: function () {\n        var tokenObservers = getState(app).tokenObservers;\n        for (var _i = 0, tokenObservers_1 = tokenObservers; _i < tokenObservers_1.length; _i++) {\n          var tokenObserver = tokenObservers_1[_i];\n          removeTokenListener(app, tokenObserver.next);\n        }\n        return Promise.resolve();\n      }\n    }\n  };\n}\nfunction internalFactory(app, platformLoggerProvider) {\n  return {\n    getToken: function (forceRefresh) {\n      return getToken$1(app, platformLoggerProvider, forceRefresh);\n    },\n    addTokenListener: function (listener) {\n      return addTokenListener(app, platformLoggerProvider, \"INTERNAL\" /* INTERNAL */, listener);\n    },\n    removeTokenListener: function (listener) {\n      return removeTokenListener(app, listener);\n    }\n  };\n}\nvar name = \"@firebase/app-check\";\nvar version = \"0.2.0\";\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nvar APP_CHECK_NAME = 'appCheck';\nvar APP_CHECK_NAME_INTERNAL = 'app-check-internal';\nfunction registerAppCheck(firebase) {\n  // The public interface\n  firebase.INTERNAL.registerComponent(new component.Component(APP_CHECK_NAME, function (container) {\n    // getImmediate for FirebaseApp will always succeed\n    var app = container.getProvider('app').getImmediate();\n    var platformLoggerProvider = container.getProvider('platform-logger');\n    return factory(app, platformLoggerProvider);\n  }, \"PUBLIC\" /* PUBLIC */)\n  /**\r\n   * AppCheck can only be initialized by explicitly calling firebase.appCheck()\r\n   * We don't want firebase products that consume AppCheck to gate on AppCheck\r\n   * if the user doesn't intend them to, just because the AppCheck component\r\n   * is registered.\r\n   */.setInstantiationMode(\"EXPLICIT\" /* EXPLICIT */)\n  /**\r\n   * Because all firebase products that depend on app-check depend on app-check-internal directly,\r\n   * we need to initialize app-check-internal after app-check is initialized to make it\r\n   * available to other firebase products.\r\n   */.setInstanceCreatedCallback(function (container, _instanceIdentifier, _instance) {\n    var appCheckInternalProvider = container.getProvider(APP_CHECK_NAME_INTERNAL);\n    appCheckInternalProvider.initialize();\n  }));\n  // The internal interface used by other Firebase products\n  firebase.INTERNAL.registerComponent(new component.Component(APP_CHECK_NAME_INTERNAL, function (container) {\n    // getImmediate for FirebaseApp will always succeed\n    var app = container.getProvider('app').getImmediate();\n    var platformLoggerProvider = container.getProvider('platform-logger');\n    return internalFactory(app, platformLoggerProvider);\n  }, \"PUBLIC\" /* PUBLIC */).setInstantiationMode(\"EXPLICIT\" /* EXPLICIT */));\n  firebase.registerVersion(name, version);\n}\nregisterAppCheck(firebase__default['default']);\ninitializeDebugMode();","map":{"version":3,"names":["ERRORS","_a","ERROR_FACTORY","util","ErrorFactory","APP_CHECK_STATES","Map","DEFAULT_STATE","activated","tokenObservers","DEBUG_STATE","enabled","getState","app","get","setState","state","set","getDebugState","getRecaptcha","self","grecaptcha","ensureActivated","create","appName","name","uuidv4","replace","c","r","Math","random","v","toString","RECAPTCHA_URL","initialize","siteKey","initialized","Deferred","tslib","__assign","reCAPTCHAState","divId","invisibleDiv","document","createElement","id","style","display","body","appendChild","loadReCAPTCHAScript","Error","ready","renderInvisibleWidget","resolve","promise","getToken$2","getToken","recaptcha","sent","Promise","_reject","execute","widgetId","action","container","render","sitekey","size","onload","script","src","head","BASE_ENDPOINT","EXCHANGE_RECAPTCHA_TOKEN_METHOD","EXCHANGE_DEBUG_TOKEN_METHOD","TOKEN_REFRESH_TIME","OFFSET_DURATION","RETRIAL_MIN_WAIT","RETRIAL_MAX_WAIT","Refresher","operation","retryPolicy","getWaitDuration","lowerBound","upperBound","pending","nextErrorWaitInterval","prototype","start","process","catch","stop","reject","isRunning","hasSucceeded","sleep","getNextRun","error_1","currentErrorWaitInterval","ms","setTimeout","exchangeToken","platformLoggerProvider","url","headers","platformLogger","getImmediate","optional","getPlatformInfoString","options","method","JSON","stringify","fetch","response","_b","originalErrorMessage","originalError_1","message","status","httpStatus","json","responseBody","originalError_2","match","ttl","isNaN","Number","timeToLiveAsNumber","now","Date","token","attestationToken","expireTimeMillis","issuedAtTimeMillis","getExchangeRecaptchaTokenRequest","reCAPTCHAToken","projectId","appId","apiKey","recaptcha_token","getExchangeDebugTokenRequest","debugToken","debug_token","DB_NAME","DB_VERSION","STORE_NAME","DEBUG_TOKEN_KEY","dbPromise","getDBPromise","request","indexedDB","open","onsuccess","event","target","result","onerror","error","onupgradeneeded","db","oldVersion","createObjectStore","keyPath","e","readTokenFromIndexedDB","read","computeKey","writeTokenToIndexedDB","write","writeDebugTokenToIndexedDB","readDebugTokenFromIndexedDB","key","value","transaction","store","objectStore","put","compositeKey","_event","undefined","logger","logger$1","Logger","readTokenFromStorage","isIndexedDBAvailable","warn","e_1","writeTokenToStorage","readOrCreateDebugTokenFromStorage","existingDebugToken","newToken","console","log","isDebugMode","debugState","getDebugToken","initializeDebugMode","globals","getGlobal","FIREBASE_APPCHECK_DEBUG_TOKEN","deferredToken","defaultTokenErrorData","formatDummyToken","tokenErrorData","base64","encodeString","getToken$1","forceRefresh","cachedToken","_d","isValid","notifyTokenListeners","apply","_c","concat","tokenFromDebugExchange","customProvider","customToken","issuedAtTimeSeconds","issuedAtTime","_e","attestedClaimsToken","interopTokenResult","makeDummyTokenResult","addTokenListener","type","listener","onError","tokenListener","next","newState","__spreadArray","tokenRefresher","createTokenRefresher","isTokenAutoRefreshEnabled","validToken_1","then","removeTokenListener","newObservers","filter","tokenObserver","length","_this","__awaiter","nextRefreshTimeMillis","latestAllowableRefresh","min","max","observers","_i","observers_1","observer","ignored","activate","siteKeyOrProvider","automaticDataCollectionEnabled","setTokenAutoRefreshEnabled","onTokenChanged","onNextOrObserver","onCompletion","nextFn","errorFn","bind","factory","INTERNAL","delete","tokenObservers_1","internalFactory","APP_CHECK_NAME","APP_CHECK_NAME_INTERNAL","registerAppCheck","firebase","registerComponent","component","Component","getProvider","setInstantiationMode","setInstanceCreatedCallback","_instanceIdentifier","_instance","appCheckInternalProvider","registerVersion","version","firebase__default"],"sources":["../src/errors.ts","../src/state.ts","../src/util.ts","../src/recaptcha.ts","../src/constants.ts","../src/proactive-refresh.ts","../src/client.ts","../src/indexeddb.ts","../src/logger.ts","../src/storage.ts","../src/debug.ts","../src/internal-api.ts","../src/api.ts","../src/factory.ts","../src/index.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ErrorFactory, ErrorMap } from '@firebase/util';\n\nexport const enum AppCheckError {\n  ALREADY_ACTIVATED = 'already-activated',\n  USE_BEFORE_ACTIVATION = 'use-before-activation',\n  FETCH_NETWORK_ERROR = 'fetch-network-error',\n  FETCH_PARSE_ERROR = 'fetch-parse-error',\n  FETCH_STATUS_ERROR = 'fetch-status-error',\n  STORAGE_OPEN = 'storage-open',\n  STORAGE_GET = 'storage-get',\n  STORAGE_WRITE = 'storage-set',\n  RECAPTCHA_ERROR = 'recaptcha-error'\n}\n\nconst ERRORS: ErrorMap<AppCheckError> = {\n  [AppCheckError.ALREADY_ACTIVATED]:\n    'You are trying to activate AppCheck for FirebaseApp {$appName}, ' +\n    'while it is already activated. ' +\n    'AppCheck can only be activated once.',\n  [AppCheckError.USE_BEFORE_ACTIVATION]:\n    'AppCheck is being used before activate() is called for FirebaseApp {$appName}. ' +\n    'Please make sure you call activate() before instantiating other Firebase services.',\n  [AppCheckError.FETCH_NETWORK_ERROR]:\n    'Fetch failed to connect to a network. Check Internet connection. ' +\n    'Original error: {$originalErrorMessage}.',\n  [AppCheckError.FETCH_PARSE_ERROR]:\n    'Fetch client could not parse response.' +\n    ' Original error: {$originalErrorMessage}.',\n  [AppCheckError.FETCH_STATUS_ERROR]:\n    'Fetch server returned an HTTP error status. HTTP status: {$httpStatus}.',\n  [AppCheckError.STORAGE_OPEN]:\n    'Error thrown when opening storage. Original error: {$originalErrorMessage}.',\n  [AppCheckError.STORAGE_GET]:\n    'Error thrown when reading from storage. Original error: {$originalErrorMessage}.',\n  [AppCheckError.STORAGE_WRITE]:\n    'Error thrown when writing to storage. Original error: {$originalErrorMessage}.',\n  [AppCheckError.RECAPTCHA_ERROR]: 'ReCAPTCHA error.'\n};\n\ninterface ErrorParams {\n  [AppCheckError.ALREADY_ACTIVATED]: { appName: string };\n  [AppCheckError.USE_BEFORE_ACTIVATION]: { appName: string };\n  [AppCheckError.FETCH_NETWORK_ERROR]: { originalErrorMessage: string };\n  [AppCheckError.FETCH_PARSE_ERROR]: { originalErrorMessage: string };\n  [AppCheckError.FETCH_STATUS_ERROR]: { httpStatus: number };\n  [AppCheckError.STORAGE_OPEN]: { originalErrorMessage?: string };\n  [AppCheckError.STORAGE_GET]: { originalErrorMessage?: string };\n  [AppCheckError.STORAGE_WRITE]: { originalErrorMessage?: string };\n}\n\nexport const ERROR_FACTORY = new ErrorFactory<AppCheckError, ErrorParams>(\n  'appCheck',\n  'AppCheck',\n  ERRORS\n);\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirebaseApp } from '@firebase/app-types';\nimport {\n  AppCheckProvider,\n  AppCheckToken,\n  AppCheckTokenResult\n} from '@firebase/app-check-types';\nimport { AppCheckTokenListener } from '@firebase/app-check-interop-types';\nimport { Refresher } from './proactive-refresh';\nimport { Deferred, PartialObserver } from '@firebase/util';\nimport { GreCAPTCHA } from './recaptcha';\n\nexport interface AppCheckTokenInternal extends AppCheckToken {\n  issuedAtTimeMillis: number;\n}\n\nexport interface AppCheckTokenObserver\n  extends PartialObserver<AppCheckTokenResult> {\n  // required\n  next: AppCheckTokenListener;\n  type: ListenerType;\n}\n\nexport const enum ListenerType {\n  'INTERNAL' = 'INTERNAL',\n  'EXTERNAL' = 'EXTERNAL'\n}\n\nexport interface AppCheckState {\n  activated: boolean;\n  tokenObservers: AppCheckTokenObserver[];\n  customProvider?: AppCheckProvider;\n  siteKey?: string;\n  token?: AppCheckTokenInternal;\n  tokenRefresher?: Refresher;\n  reCAPTCHAState?: ReCAPTCHAState;\n  isTokenAutoRefreshEnabled?: boolean;\n}\n\nexport interface ReCAPTCHAState {\n  initialized: Deferred<GreCAPTCHA>;\n  widgetId?: string;\n}\n\nexport interface DebugState {\n  enabled: boolean;\n  // This is the debug token string the user interacts with.\n  token?: Deferred<string>;\n}\n\nconst APP_CHECK_STATES = new Map<FirebaseApp, AppCheckState>();\nexport const DEFAULT_STATE: AppCheckState = {\n  activated: false,\n  tokenObservers: []\n};\n\nconst DEBUG_STATE: DebugState = {\n  enabled: false\n};\n\nexport function getState(app: FirebaseApp): AppCheckState {\n  return APP_CHECK_STATES.get(app) || DEFAULT_STATE;\n}\n\nexport function setState(app: FirebaseApp, state: AppCheckState): void {\n  APP_CHECK_STATES.set(app, state);\n}\n\n// for testing only\nexport function clearState(): void {\n  APP_CHECK_STATES.clear();\n  DEBUG_STATE.enabled = false;\n  DEBUG_STATE.token = undefined;\n}\n\nexport function getDebugState(): DebugState {\n  return DEBUG_STATE;\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { GreCAPTCHA } from './recaptcha';\nimport { getState } from './state';\nimport { ERROR_FACTORY, AppCheckError } from './errors';\nimport { FirebaseApp } from '@firebase/app-types';\n\nexport function getRecaptcha(): GreCAPTCHA | undefined {\n  return self.grecaptcha;\n}\n\nexport function ensureActivated(app: FirebaseApp): void {\n  if (!getState(app).activated) {\n    throw ERROR_FACTORY.create(AppCheckError.USE_BEFORE_ACTIVATION, {\n      appName: app.name\n    });\n  }\n}\n\n/**\n * Copied from https://stackoverflow.com/a/2117523\n */\nexport function uuidv4(): string {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n    const r = (Math.random() * 16) | 0,\n      v = c === 'x' ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirebaseApp } from '@firebase/app-types';\nimport { getState, setState } from './state';\nimport { Deferred } from '@firebase/util';\nimport { getRecaptcha, ensureActivated } from './util';\n\nexport const RECAPTCHA_URL = 'https://www.google.com/recaptcha/api.js';\n\nexport function initialize(\n  app: FirebaseApp,\n  siteKey: string\n): Promise<GreCAPTCHA> {\n  const state = getState(app);\n  const initialized = new Deferred<GreCAPTCHA>();\n\n  setState(app, { ...state, reCAPTCHAState: { initialized } });\n\n  const divId = `fire_app_check_${app.name}`;\n  const invisibleDiv = document.createElement('div');\n  invisibleDiv.id = divId;\n  invisibleDiv.style.display = 'none';\n\n  document.body.appendChild(invisibleDiv);\n\n  const grecaptcha = getRecaptcha();\n  if (!grecaptcha) {\n    loadReCAPTCHAScript(() => {\n      const grecaptcha = getRecaptcha();\n\n      if (!grecaptcha) {\n        // it shouldn't happen.\n        throw new Error('no recaptcha');\n      }\n      grecaptcha.ready(() => {\n        // Invisible widgets allow us to set a different siteKey for each widget, so we use them to support multiple apps\n        renderInvisibleWidget(app, siteKey, grecaptcha, divId);\n        initialized.resolve(grecaptcha);\n      });\n    });\n  } else {\n    grecaptcha.ready(() => {\n      renderInvisibleWidget(app, siteKey, grecaptcha, divId);\n      initialized.resolve(grecaptcha);\n    });\n  }\n\n  return initialized.promise;\n}\n\nexport async function getToken(app: FirebaseApp): Promise<string> {\n  ensureActivated(app);\n\n  // ensureActivated() guarantees that reCAPTCHAState is set\n  const reCAPTCHAState = getState(app).reCAPTCHAState!;\n  const recaptcha = await reCAPTCHAState.initialized.promise;\n\n  return new Promise((resolve, _reject) => {\n    // Updated after initialization is complete.\n    const reCAPTCHAState = getState(app).reCAPTCHAState!;\n    recaptcha.ready(() => {\n      resolve(\n        // widgetId is guaranteed to be available if reCAPTCHAState.initialized.promise resolved.\n        recaptcha.execute(reCAPTCHAState.widgetId!, {\n          action: 'fire_app_check'\n        })\n      );\n    });\n  });\n}\n\n/**\n *\n * @param app\n * @param container - Id of a HTML element.\n */\nfunction renderInvisibleWidget(\n  app: FirebaseApp,\n  siteKey: string,\n  grecaptcha: GreCAPTCHA,\n  container: string\n): void {\n  const widgetId = grecaptcha.render(container, {\n    sitekey: siteKey,\n    size: 'invisible'\n  });\n\n  const state = getState(app);\n\n  setState(app, {\n    ...state,\n    reCAPTCHAState: {\n      ...state.reCAPTCHAState!, // state.reCAPTCHAState is set in the initialize()\n      widgetId\n    }\n  });\n}\n\nfunction loadReCAPTCHAScript(onload: () => void): void {\n  const script = document.createElement('script');\n  script.src = `${RECAPTCHA_URL}`;\n  script.onload = onload;\n  document.head.appendChild(script);\n}\n\ndeclare global {\n  interface Window {\n    grecaptcha: GreCAPTCHA | undefined;\n  }\n}\n\nexport interface GreCAPTCHA {\n  ready: (callback: () => void) => void;\n  execute: (siteKey: string, options: { action: string }) => Promise<string>;\n  render: (\n    container: string | HTMLElement,\n    parameters: GreCAPTCHARenderOption\n  ) => string;\n}\n\nexport interface GreCAPTCHARenderOption {\n  sitekey: string;\n  size: 'invisible';\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport const BASE_ENDPOINT =\n  'https://content-firebaseappcheck.googleapis.com/v1beta';\n\nexport const EXCHANGE_RECAPTCHA_TOKEN_METHOD = 'exchangeRecaptchaToken';\nexport const EXCHANGE_DEBUG_TOKEN_METHOD = 'exchangeDebugToken';\n\nexport const TOKEN_REFRESH_TIME = {\n  /**\n   * The offset time before token natural expiration to run the refresh.\n   * This is currently 5 minutes.\n   */\n  OFFSET_DURATION: 5 * 60 * 1000,\n  /**\n   * This is the first retrial wait after an error. This is currently\n   * 30 seconds.\n   */\n  RETRIAL_MIN_WAIT: 30 * 1000,\n  /**\n   * This is the maximum retrial wait, currently 16 minutes.\n   */\n  RETRIAL_MAX_WAIT: 16 * 60 * 1000\n};\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Deferred } from '@firebase/util';\n\n/**\n * Port from auth proactiverefresh.js\n *\n */\n// TODO: move it to @firebase/util?\n// TODO: allow to config whether refresh should happen in the background\nexport class Refresher {\n  private pending: Deferred<unknown> | null = null;\n  private nextErrorWaitInterval: number;\n  constructor(\n    private readonly operation: () => Promise<unknown>,\n    private readonly retryPolicy: (error: unknown) => boolean,\n    private readonly getWaitDuration: () => number,\n    private readonly lowerBound: number,\n    private readonly upperBound: number\n  ) {\n    this.nextErrorWaitInterval = lowerBound;\n\n    if (lowerBound > upperBound) {\n      throw new Error(\n        'Proactive refresh lower bound greater than upper bound!'\n      );\n    }\n  }\n\n  start(): void {\n    this.nextErrorWaitInterval = this.lowerBound;\n    this.process(true).catch(() => {\n      /* we don't care about the result */\n    });\n  }\n\n  stop(): void {\n    if (this.pending) {\n      this.pending.reject('cancelled');\n      this.pending = null;\n    }\n  }\n\n  isRunning(): boolean {\n    return !!this.pending;\n  }\n\n  private async process(hasSucceeded: boolean): Promise<void> {\n    this.stop();\n    try {\n      this.pending = new Deferred();\n      await sleep(this.getNextRun(hasSucceeded));\n\n      // Why do we resolve a promise, then immediate wait for it?\n      // We do it to make the promise chain cancellable.\n      // We can call stop() which rejects the promise before the following line execute, which makes\n      // the code jump to the catch block.\n      // TODO: unit test this\n      this.pending.resolve();\n      await this.pending.promise;\n      this.pending = new Deferred();\n      await this.operation();\n\n      this.pending.resolve();\n      await this.pending.promise;\n\n      this.process(true).catch(() => {\n        /* we don't care about the result */\n      });\n    } catch (error) {\n      if (this.retryPolicy(error)) {\n        this.process(false).catch(() => {\n          /* we don't care about the result */\n        });\n      } else {\n        this.stop();\n      }\n    }\n  }\n\n  private getNextRun(hasSucceeded: boolean): number {\n    if (hasSucceeded) {\n      // If last operation succeeded, reset next error wait interval and return\n      // the default wait duration.\n      this.nextErrorWaitInterval = this.lowerBound;\n      // Return typical wait duration interval after a successful operation.\n      return this.getWaitDuration();\n    } else {\n      // Get next error wait interval.\n      const currentErrorWaitInterval = this.nextErrorWaitInterval;\n      // Double interval for next consecutive error.\n      this.nextErrorWaitInterval *= 2;\n      // Make sure next wait interval does not exceed the maximum upper bound.\n      if (this.nextErrorWaitInterval > this.upperBound) {\n        this.nextErrorWaitInterval = this.upperBound;\n      }\n      return currentErrorWaitInterval;\n    }\n  }\n}\n\nfunction sleep(ms: number): Promise<void> {\n  return new Promise<void>(resolve => {\n    setTimeout(resolve, ms);\n  });\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  BASE_ENDPOINT,\n  EXCHANGE_DEBUG_TOKEN_METHOD,\n  EXCHANGE_RECAPTCHA_TOKEN_METHOD\n} from './constants';\nimport { FirebaseApp } from '@firebase/app-types';\nimport { ERROR_FACTORY, AppCheckError } from './errors';\nimport { Provider } from '@firebase/component';\nimport { AppCheckTokenInternal } from './state';\n\n/**\n * Response JSON returned from AppCheck server endpoint.\n */\ninterface AppCheckResponse {\n  attestationToken: string;\n  // timeToLive\n  ttl: string;\n}\n\ninterface AppCheckRequest {\n  url: string;\n  body: { [key: string]: string };\n}\n\nexport async function exchangeToken(\n  { url, body }: AppCheckRequest,\n  platformLoggerProvider: Provider<'platform-logger'>\n): Promise<AppCheckTokenInternal> {\n  const headers: HeadersInit = {\n    'Content-Type': 'application/json'\n  };\n  // If platform logger exists, add the platform info string to the header.\n  const platformLogger = platformLoggerProvider.getImmediate({\n    optional: true\n  });\n  if (platformLogger) {\n    headers['X-Firebase-Client'] = platformLogger.getPlatformInfoString();\n  }\n  const options: RequestInit = {\n    method: 'POST',\n    body: JSON.stringify(body),\n    headers\n  };\n  let response;\n  try {\n    response = await fetch(url, options);\n  } catch (originalError) {\n    throw ERROR_FACTORY.create(AppCheckError.FETCH_NETWORK_ERROR, {\n      originalErrorMessage: originalError.message\n    });\n  }\n\n  if (response.status !== 200) {\n    throw ERROR_FACTORY.create(AppCheckError.FETCH_STATUS_ERROR, {\n      httpStatus: response.status\n    });\n  }\n\n  let responseBody: AppCheckResponse;\n  try {\n    // JSON parsing throws SyntaxError if the response body isn't a JSON string.\n    responseBody = await response.json();\n  } catch (originalError) {\n    throw ERROR_FACTORY.create(AppCheckError.FETCH_PARSE_ERROR, {\n      originalErrorMessage: originalError.message\n    });\n  }\n\n  // Protobuf duration format.\n  // https://developers.google.com/protocol-buffers/docs/reference/java/com/google/protobuf/Duration\n  const match = responseBody.ttl.match(/^([\\d.]+)(s)$/);\n  if (!match || !match[2] || isNaN(Number(match[1]))) {\n    throw ERROR_FACTORY.create(AppCheckError.FETCH_PARSE_ERROR, {\n      originalErrorMessage:\n        `ttl field (timeToLive) is not in standard Protobuf Duration ` +\n        `format: ${responseBody.ttl}`\n    });\n  }\n  const timeToLiveAsNumber = Number(match[1]) * 1000;\n\n  const now = Date.now();\n  return {\n    token: responseBody.attestationToken,\n    expireTimeMillis: now + timeToLiveAsNumber,\n    issuedAtTimeMillis: now\n  };\n}\n\nexport function getExchangeRecaptchaTokenRequest(\n  app: FirebaseApp,\n  reCAPTCHAToken: string\n): AppCheckRequest {\n  const { projectId, appId, apiKey } = app.options;\n\n  return {\n    url: `${BASE_ENDPOINT}/projects/${projectId}/apps/${appId}:${EXCHANGE_RECAPTCHA_TOKEN_METHOD}?key=${apiKey}`,\n    body: {\n      // eslint-disable-next-line\n      recaptcha_token: reCAPTCHAToken\n    }\n  };\n}\n\nexport function getExchangeDebugTokenRequest(\n  app: FirebaseApp,\n  debugToken: string\n): AppCheckRequest {\n  const { projectId, appId, apiKey } = app.options;\n\n  return {\n    url: `${BASE_ENDPOINT}/projects/${projectId}/apps/${appId}:${EXCHANGE_DEBUG_TOKEN_METHOD}?key=${apiKey}`,\n    body: {\n      // eslint-disable-next-line\n      debug_token: debugToken\n    }\n  };\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirebaseApp } from '@firebase/app-types';\nimport { ERROR_FACTORY, AppCheckError } from './errors';\nimport { AppCheckTokenInternal } from './state';\nconst DB_NAME = 'firebase-app-check-database';\nconst DB_VERSION = 1;\nconst STORE_NAME = 'firebase-app-check-store';\nconst DEBUG_TOKEN_KEY = 'debug-token';\n\nlet dbPromise: Promise<IDBDatabase> | null = null;\nfunction getDBPromise(): Promise<IDBDatabase> {\n  if (dbPromise) {\n    return dbPromise;\n  }\n\n  dbPromise = new Promise((resolve, reject) => {\n    try {\n      const request = indexedDB.open(DB_NAME, DB_VERSION);\n\n      request.onsuccess = event => {\n        resolve((event.target as IDBOpenDBRequest).result);\n      };\n\n      request.onerror = event => {\n        reject(\n          ERROR_FACTORY.create(AppCheckError.STORAGE_OPEN, {\n            originalErrorMessage: (event.target as IDBRequest).error?.message\n          })\n        );\n      };\n\n      request.onupgradeneeded = event => {\n        const db = (event.target as IDBOpenDBRequest).result;\n\n        // We don't use 'break' in this switch statement, the fall-through\n        // behavior is what we want, because if there are multiple versions between\n        // the old version and the current version, we want ALL the migrations\n        // that correspond to those versions to run, not only the last one.\n        // eslint-disable-next-line default-case\n        switch (event.oldVersion) {\n          case 0:\n            db.createObjectStore(STORE_NAME, {\n              keyPath: 'compositeKey'\n            });\n        }\n      };\n    } catch (e) {\n      reject(\n        ERROR_FACTORY.create(AppCheckError.STORAGE_OPEN, {\n          originalErrorMessage: e.message\n        })\n      );\n    }\n  });\n\n  return dbPromise;\n}\n\nexport function readTokenFromIndexedDB(\n  app: FirebaseApp\n): Promise<AppCheckTokenInternal | undefined> {\n  return read(computeKey(app)) as Promise<AppCheckTokenInternal | undefined>;\n}\n\nexport function writeTokenToIndexedDB(\n  app: FirebaseApp,\n  token: AppCheckTokenInternal\n): Promise<void> {\n  return write(computeKey(app), token);\n}\n\nexport function writeDebugTokenToIndexedDB(token: string): Promise<void> {\n  return write(DEBUG_TOKEN_KEY, token);\n}\n\nexport function readDebugTokenFromIndexedDB(): Promise<string | undefined> {\n  return read(DEBUG_TOKEN_KEY) as Promise<string | undefined>;\n}\n\nasync function write(key: string, value: unknown): Promise<void> {\n  const db = await getDBPromise();\n\n  const transaction = db.transaction(STORE_NAME, 'readwrite');\n  const store = transaction.objectStore(STORE_NAME);\n  const request = store.put({\n    compositeKey: key,\n    value\n  });\n\n  return new Promise((resolve, reject) => {\n    request.onsuccess = _event => {\n      resolve();\n    };\n\n    transaction.onerror = event => {\n      reject(\n        ERROR_FACTORY.create(AppCheckError.STORAGE_WRITE, {\n          originalErrorMessage: (event.target as IDBRequest).error?.message\n        })\n      );\n    };\n  });\n}\n\nasync function read(key: string): Promise<unknown> {\n  const db = await getDBPromise();\n\n  const transaction = db.transaction(STORE_NAME, 'readonly');\n  const store = transaction.objectStore(STORE_NAME);\n  const request = store.get(key);\n\n  return new Promise((resolve, reject) => {\n    request.onsuccess = event => {\n      const result = (event.target as IDBRequest).result;\n\n      if (result) {\n        resolve(result.value);\n      } else {\n        resolve(undefined);\n      }\n    };\n\n    transaction.onerror = event => {\n      reject(\n        ERROR_FACTORY.create(AppCheckError.STORAGE_GET, {\n          originalErrorMessage: (event.target as IDBRequest).error?.message\n        })\n      );\n    };\n  });\n}\n\nfunction computeKey(app: FirebaseApp): string {\n  return `${app.options.appId}-${app.name}`;\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Logger } from '@firebase/logger';\n\nexport const logger = new Logger('@firebase/app-check');\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { uuidv4 } from './util';\nimport { FirebaseApp } from '@firebase/app-types';\nimport { isIndexedDBAvailable } from '@firebase/util';\nimport {\n  readDebugTokenFromIndexedDB,\n  readTokenFromIndexedDB,\n  writeDebugTokenToIndexedDB,\n  writeTokenToIndexedDB\n} from './indexeddb';\nimport { logger } from './logger';\nimport { AppCheckTokenInternal } from './state';\n\n/**\n * Always resolves. In case of an error reading from indexeddb, resolve with undefined\n */\nexport async function readTokenFromStorage(\n  app: FirebaseApp\n): Promise<AppCheckTokenInternal | undefined> {\n  if (isIndexedDBAvailable()) {\n    let token = undefined;\n    try {\n      token = await readTokenFromIndexedDB(app);\n    } catch (e) {\n      // swallow the error and return undefined\n      logger.warn(`Failed to read token from indexeddb. Error: ${e}`);\n    }\n    return token;\n  }\n\n  return undefined;\n}\n\n/**\n * Always resolves. In case of an error writing to indexeddb, print a warning and resolve the promise\n */\nexport function writeTokenToStorage(\n  app: FirebaseApp,\n  token: AppCheckTokenInternal\n): Promise<void> {\n  if (isIndexedDBAvailable()) {\n    return writeTokenToIndexedDB(app, token).catch(e => {\n      // swallow the error and resolve the promise\n      logger.warn(`Failed to write token to indexeddb. Error: ${e}`);\n    });\n  }\n\n  return Promise.resolve();\n}\n\nexport async function readOrCreateDebugTokenFromStorage(): Promise<string> {\n  /**\n   * Theoretically race condition can happen if we read, then write in 2 separate transactions.\n   * But it won't happen here, because this function will be called exactly once.\n   */\n  let existingDebugToken: string | undefined = undefined;\n  try {\n    existingDebugToken = await readDebugTokenFromIndexedDB();\n  } catch (_e) {\n    // failed to read from indexeddb. We assume there is no existing debug token, and generate a new one.\n  }\n\n  if (!existingDebugToken) {\n    // create a new debug token\n    const newToken = uuidv4();\n    // We don't need to block on writing to indexeddb\n    // In case persistence failed, a new debug token will be generated everytime the page is refreshed.\n    // It renders the debug token useless because you have to manually register(whitelist) the new token in the firebase console again and again.\n    // If you see this error trying to use debug token, it probably means you are using a browser that doesn't support indexeddb.\n    // You should switch to a different browser that supports indexeddb\n    writeDebugTokenToIndexedDB(newToken).catch(e =>\n      logger.warn(`Failed to persist debug token to indexeddb. Error: ${e}`)\n    );\n    // Not using logger because I don't think we ever want this accidentally hidden?\n    console.log(\n      `AppCheck debug token: ${newToken}. You will need to whitelist it in the Firebase console for it to work`\n    );\n    return newToken;\n  } else {\n    return existingDebugToken;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getDebugState } from './state';\nimport { readOrCreateDebugTokenFromStorage } from './storage';\nimport { Deferred, getGlobal } from '@firebase/util';\n\ndeclare global {\n  // var must be used for global scopes\n  // https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#type-checking-for-globalthis\n  // eslint-disable-next-line no-var\n  var FIREBASE_APPCHECK_DEBUG_TOKEN: boolean | string | undefined;\n}\n\nexport function isDebugMode(): boolean {\n  const debugState = getDebugState();\n  return debugState.enabled;\n}\n\nexport async function getDebugToken(): Promise<string> {\n  const state = getDebugState();\n\n  if (state.enabled && state.token) {\n    return state.token.promise;\n  } else {\n    // should not happen!\n    throw Error(`\n            Can't get debug token in production mode.\n        `);\n  }\n}\n\nexport function initializeDebugMode(): void {\n  const globals = getGlobal();\n  if (\n    typeof globals.FIREBASE_APPCHECK_DEBUG_TOKEN !== 'string' &&\n    globals.FIREBASE_APPCHECK_DEBUG_TOKEN !== true\n  ) {\n    return;\n  }\n\n  const debugState = getDebugState();\n  debugState.enabled = true;\n  const deferredToken = new Deferred<string>();\n  debugState.token = deferredToken;\n\n  if (typeof globals.FIREBASE_APPCHECK_DEBUG_TOKEN === 'string') {\n    deferredToken.resolve(globals.FIREBASE_APPCHECK_DEBUG_TOKEN);\n  } else {\n    deferredToken.resolve(readOrCreateDebugTokenFromStorage());\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getToken as getReCAPTCHAToken } from './recaptcha';\nimport { FirebaseApp } from '@firebase/app-types';\nimport {\n  AppCheckTokenListener,\n  AppCheckTokenResult\n} from '@firebase/app-check-interop-types';\nimport {\n  AppCheckTokenInternal,\n  AppCheckTokenObserver,\n  getState,\n  ListenerType,\n  setState\n} from './state';\nimport { TOKEN_REFRESH_TIME } from './constants';\nimport { Refresher } from './proactive-refresh';\nimport { ensureActivated } from './util';\nimport {\n  exchangeToken,\n  getExchangeDebugTokenRequest,\n  getExchangeRecaptchaTokenRequest\n} from './client';\nimport { writeTokenToStorage, readTokenFromStorage } from './storage';\nimport { getDebugToken, isDebugMode } from './debug';\nimport { base64, issuedAtTime } from '@firebase/util';\nimport { ERROR_FACTORY, AppCheckError } from './errors';\nimport { logger } from './logger';\nimport { Provider } from '@firebase/component';\n\n// Initial hardcoded value agreed upon across platforms for initial launch.\n// Format left open for possible dynamic error values and other fields in the future.\nexport const defaultTokenErrorData = { error: 'UNKNOWN_ERROR' };\n\n/**\n * Stringify and base64 encode token error data.\n *\n * @param tokenError Error data, currently hardcoded.\n */\nexport function formatDummyToken(\n  tokenErrorData: Record<string, string>\n): string {\n  return base64.encodeString(\n    JSON.stringify(tokenErrorData),\n    /* webSafe= */ false\n  );\n}\n\n/**\n * This function will always resolve.\n * The result will contain an error field if there is any error.\n * In case there is an error, the token field in the result will be populated with a dummy value\n */\nexport async function getToken(\n  app: FirebaseApp,\n  platformLoggerProvider: Provider<'platform-logger'>,\n  forceRefresh = false\n): Promise<AppCheckTokenResult> {\n  ensureActivated(app);\n\n  const state = getState(app);\n\n  /**\n   * First check if there is a token in memory from a previous `getToken()` call.\n   */\n  let token: AppCheckTokenInternal | undefined = state.token;\n  let error: Error | undefined = undefined;\n\n  /**\n   * If there is no token in memory, try to load token from indexedDB.\n   */\n  if (!token) {\n    // readTokenFromStorage() always resolves. In case of an error, it resolves with `undefined`.\n    const cachedToken = await readTokenFromStorage(app);\n    if (cachedToken && isValid(cachedToken)) {\n      token = cachedToken;\n\n      setState(app, { ...state, token });\n      // notify all listeners with the cached token\n      notifyTokenListeners(app, { token: token.token });\n    }\n  }\n\n  // Return the cached token (from either memory or indexedDB) if it's valid\n  if (!forceRefresh && token && isValid(token)) {\n    return {\n      token: token.token\n    };\n  }\n\n  /**\n   * DEBUG MODE\n   * If debug mode is set, and there is no cached token, fetch a new App\n   * Check token using the debug token, and return it directly.\n   */\n  if (isDebugMode()) {\n    const tokenFromDebugExchange: AppCheckTokenInternal = await exchangeToken(\n      getExchangeDebugTokenRequest(app, await getDebugToken()),\n      platformLoggerProvider\n    );\n    // Write debug token to indexedDB.\n    await writeTokenToStorage(app, tokenFromDebugExchange);\n    // Write debug token to state.\n    setState(app, { ...state, token: tokenFromDebugExchange });\n    return { token: tokenFromDebugExchange.token };\n  }\n\n  /**\n   * request a new token\n   */\n  try {\n    if (state.customProvider) {\n      const customToken = await state.customProvider.getToken();\n      // Try to extract IAT from custom token, in case this token is not\n      // being newly issued. JWT timestamps are in seconds since epoch.\n      const issuedAtTimeSeconds = issuedAtTime(customToken.token);\n      // Very basic validation, use current timestamp as IAT if JWT\n      // has no `iat` field or value is out of bounds.\n      const issuedAtTimeMillis =\n        issuedAtTimeSeconds !== null &&\n        issuedAtTimeSeconds < Date.now() &&\n        issuedAtTimeSeconds > 0\n          ? issuedAtTimeSeconds * 1000\n          : Date.now();\n\n      token = { ...customToken, issuedAtTimeMillis };\n    } else {\n      const attestedClaimsToken = await getReCAPTCHAToken(app).catch(_e => {\n        // reCaptcha.execute() throws null which is not very descriptive.\n        throw ERROR_FACTORY.create(AppCheckError.RECAPTCHA_ERROR);\n      });\n      token = await exchangeToken(\n        getExchangeRecaptchaTokenRequest(app, attestedClaimsToken),\n        platformLoggerProvider\n      );\n    }\n  } catch (e) {\n    // `getToken()` should never throw, but logging error text to console will aid debugging.\n    logger.error(e);\n    error = e;\n  }\n\n  let interopTokenResult: AppCheckTokenResult | undefined;\n  if (!token) {\n    // if token is undefined, there must be an error.\n    // we return a dummy token along with the error\n    interopTokenResult = makeDummyTokenResult(error!);\n  } else {\n    interopTokenResult = {\n      token: token.token\n    };\n    // write the new token to the memory state as well as the persistent storage.\n    // Only do it if we got a valid new token\n    setState(app, { ...state, token });\n    await writeTokenToStorage(app, token);\n  }\n\n  notifyTokenListeners(app, interopTokenResult);\n  return interopTokenResult;\n}\n\nexport function addTokenListener(\n  app: FirebaseApp,\n  platformLoggerProvider: Provider<'platform-logger'>,\n  type: ListenerType,\n  listener: AppCheckTokenListener,\n  onError?: (error: Error) => void\n): void {\n  const state = getState(app);\n  const tokenListener: AppCheckTokenObserver = {\n    next: listener,\n    error: onError,\n    type\n  };\n  const newState = {\n    ...state,\n    tokenObservers: [...state.tokenObservers, tokenListener]\n  };\n\n  /**\n   * Invoke the listener with the valid token, then start the token refresher\n   */\n  if (!newState.tokenRefresher) {\n    const tokenRefresher = createTokenRefresher(app, platformLoggerProvider);\n    newState.tokenRefresher = tokenRefresher;\n  }\n\n  // Create the refresher but don't start it if `isTokenAutoRefreshEnabled`\n  // is not true.\n  if (\n    !newState.tokenRefresher.isRunning() &&\n    state.isTokenAutoRefreshEnabled === true\n  ) {\n    newState.tokenRefresher.start();\n  }\n\n  // invoke the listener async immediately if there is a valid token\n  if (state.token && isValid(state.token)) {\n    const validToken = state.token;\n    Promise.resolve()\n      .then(() => listener({ token: validToken.token }))\n      .catch(() => {\n        /** Ignore errors in listeners. */\n      });\n  }\n\n  setState(app, newState);\n}\n\nexport function removeTokenListener(\n  app: FirebaseApp,\n  listener: (token: AppCheckTokenResult) => void\n): void {\n  const state = getState(app);\n\n  const newObservers = state.tokenObservers.filter(\n    tokenObserver => tokenObserver.next !== listener\n  );\n  if (\n    newObservers.length === 0 &&\n    state.tokenRefresher &&\n    state.tokenRefresher.isRunning()\n  ) {\n    state.tokenRefresher.stop();\n  }\n\n  setState(app, {\n    ...state,\n    tokenObservers: newObservers\n  });\n}\n\nfunction createTokenRefresher(\n  app: FirebaseApp,\n  platformLoggerProvider: Provider<'platform-logger'>\n): Refresher {\n  return new Refresher(\n    // Keep in mind when this fails for any reason other than the ones\n    // for which we should retry, it will effectively stop the proactive refresh.\n    async () => {\n      const state = getState(app);\n      // If there is no token, we will try to load it from storage and use it\n      // If there is a token, we force refresh it because we know it's going to expire soon\n      let result;\n      if (!state.token) {\n        result = await getToken(app, platformLoggerProvider);\n      } else {\n        result = await getToken(app, platformLoggerProvider, true);\n      }\n\n      // getToken() always resolves. In case the result has an error field defined, it means the operation failed, and we should retry.\n      if (result.error) {\n        throw result.error;\n      }\n    },\n    () => {\n      // TODO: when should we retry?\n      return true;\n    },\n    () => {\n      const state = getState(app);\n\n      if (state.token) {\n        // issuedAtTime + (50% * total TTL) + 5 minutes\n        let nextRefreshTimeMillis =\n          state.token.issuedAtTimeMillis +\n          (state.token.expireTimeMillis - state.token.issuedAtTimeMillis) *\n            0.5 +\n          5 * 60 * 1000;\n        // Do not allow refresh time to be past (expireTime - 5 minutes)\n        const latestAllowableRefresh =\n          state.token.expireTimeMillis - 5 * 60 * 1000;\n        nextRefreshTimeMillis = Math.min(\n          nextRefreshTimeMillis,\n          latestAllowableRefresh\n        );\n        return Math.max(0, nextRefreshTimeMillis - Date.now());\n      } else {\n        return 0;\n      }\n    },\n    TOKEN_REFRESH_TIME.RETRIAL_MIN_WAIT,\n    TOKEN_REFRESH_TIME.RETRIAL_MAX_WAIT\n  );\n}\n\nfunction notifyTokenListeners(\n  app: FirebaseApp,\n  token: AppCheckTokenResult\n): void {\n  const observers = getState(app).tokenObservers;\n\n  for (const observer of observers) {\n    try {\n      if (observer.type === ListenerType.EXTERNAL && token.error != null) {\n        // If this listener was added by a 3P call, send any token error to\n        // the supplied error handler. A 3P observer always has an error\n        // handler.\n        observer.error!(token.error);\n      } else {\n        // If the token has no error field, always return the token.\n        // If this is a 2P listener, return the token, whether or not it\n        // has an error field.\n        observer.next(token);\n      }\n    } catch (ignored) {\n      // Errors in the listener function itself are always ignored.\n    }\n  }\n}\n\nfunction isValid(token: AppCheckTokenInternal): boolean {\n  return token.expireTimeMillis - Date.now() > 0;\n}\n\nfunction makeDummyTokenResult(error: Error): AppCheckTokenResult {\n  return {\n    token: formatDummyToken(defaultTokenErrorData),\n    error\n  };\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  AppCheckProvider,\n  AppCheckTokenResult\n} from '@firebase/app-check-types';\nimport { FirebaseApp } from '@firebase/app-types';\nimport { ERROR_FACTORY, AppCheckError } from './errors';\nimport { initialize as initializeRecaptcha } from './recaptcha';\nimport { getState, setState, AppCheckState, ListenerType } from './state';\nimport {\n  getToken as getTokenInternal,\n  addTokenListener,\n  removeTokenListener\n} from './internal-api';\nimport { Provider } from '@firebase/component';\nimport { ErrorFn, NextFn, PartialObserver, Unsubscribe } from '@firebase/util';\n\n/**\n *\n * @param app\n * @param siteKeyOrProvider - optional custom attestation provider\n * or reCAPTCHA siteKey\n * @param isTokenAutoRefreshEnabled - if true, enables auto refresh\n * of appCheck token.\n */\nexport function activate(\n  app: FirebaseApp,\n  siteKeyOrProvider: string | AppCheckProvider,\n  isTokenAutoRefreshEnabled?: boolean\n): void {\n  const state = getState(app);\n  if (state.activated) {\n    throw ERROR_FACTORY.create(AppCheckError.ALREADY_ACTIVATED, {\n      appName: app.name\n    });\n  }\n\n  const newState: AppCheckState = { ...state, activated: true };\n  if (typeof siteKeyOrProvider === 'string') {\n    newState.siteKey = siteKeyOrProvider;\n  } else {\n    newState.customProvider = siteKeyOrProvider;\n  }\n\n  // Use value of global `automaticDataCollectionEnabled` (which\n  // itself defaults to false if not specified in config) if\n  // `isTokenAutoRefreshEnabled` param was not provided by user.\n  newState.isTokenAutoRefreshEnabled =\n    isTokenAutoRefreshEnabled === undefined\n      ? app.automaticDataCollectionEnabled\n      : isTokenAutoRefreshEnabled;\n\n  setState(app, newState);\n\n  // initialize reCAPTCHA if siteKey is provided\n  if (newState.siteKey) {\n    initializeRecaptcha(app, newState.siteKey).catch(() => {\n      /* we don't care about the initialization result in activate() */\n    });\n  }\n}\n\nexport function setTokenAutoRefreshEnabled(\n  app: FirebaseApp,\n  isTokenAutoRefreshEnabled: boolean\n): void {\n  const state = getState(app);\n  // This will exist if any product libraries have called\n  // `addTokenListener()`\n  if (state.tokenRefresher) {\n    if (isTokenAutoRefreshEnabled === true) {\n      state.tokenRefresher.start();\n    } else {\n      state.tokenRefresher.stop();\n    }\n  }\n  setState(app, { ...state, isTokenAutoRefreshEnabled });\n}\n\n/**\n * Differs from internal getToken in that it throws the error.\n */\nexport async function getToken(\n  app: FirebaseApp,\n  platformLoggerProvider: Provider<'platform-logger'>,\n  forceRefresh?: boolean\n): Promise<AppCheckTokenResult> {\n  const result = await getTokenInternal(\n    app,\n    platformLoggerProvider,\n    forceRefresh\n  );\n  if (result.error) {\n    throw result.error;\n  }\n  return { token: result.token };\n}\n\n/**\n * Wraps addTokenListener/removeTokenListener methods in an Observer\n * pattern for public use.\n */\nexport function onTokenChanged(\n  app: FirebaseApp,\n  platformLoggerProvider: Provider<'platform-logger'>,\n  observer: PartialObserver<AppCheckTokenResult>\n): Unsubscribe;\nexport function onTokenChanged(\n  app: FirebaseApp,\n  platformLoggerProvider: Provider<'platform-logger'>,\n  onNext: (tokenResult: AppCheckTokenResult) => void,\n  onError?: (error: Error) => void,\n  onCompletion?: () => void\n): Unsubscribe;\nexport function onTokenChanged(\n  app: FirebaseApp,\n  platformLoggerProvider: Provider<'platform-logger'>,\n  onNextOrObserver:\n    | ((tokenResult: AppCheckTokenResult) => void)\n    | PartialObserver<AppCheckTokenResult>,\n  onError?: (error: Error) => void,\n  /**\n   * NOTE: Although an `onCompletion` callback can be provided, it will\n   * never be called because the token stream is never-ending.\n   * It is added only for API consistency with the observer pattern, which\n   * we follow in JS APIs.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  onCompletion?: () => void\n): Unsubscribe {\n  let nextFn: NextFn<AppCheckTokenResult> = () => {};\n  let errorFn: ErrorFn = () => {};\n  if ((onNextOrObserver as PartialObserver<AppCheckTokenResult>).next != null) {\n    nextFn = (\n      onNextOrObserver as PartialObserver<AppCheckTokenResult>\n    ).next!.bind(onNextOrObserver);\n  } else {\n    nextFn = onNextOrObserver as NextFn<AppCheckTokenResult>;\n  }\n  if (\n    (onNextOrObserver as PartialObserver<AppCheckTokenResult>).error != null\n  ) {\n    errorFn = (\n      onNextOrObserver as PartialObserver<AppCheckTokenResult>\n    ).error!.bind(onNextOrObserver);\n  } else if (onError) {\n    errorFn = onError;\n  }\n  addTokenListener(\n    app,\n    platformLoggerProvider,\n    ListenerType.EXTERNAL,\n    nextFn,\n    errorFn\n  );\n  return () => removeTokenListener(app, nextFn);\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  FirebaseAppCheck,\n  AppCheckProvider,\n  AppCheckTokenResult\n} from '@firebase/app-check-types';\nimport {\n  activate,\n  setTokenAutoRefreshEnabled,\n  getToken,\n  onTokenChanged\n} from './api';\nimport { FirebaseApp } from '@firebase/app-types';\nimport { FirebaseAppCheckInternal } from '@firebase/app-check-interop-types';\nimport {\n  getToken as getTokenInternal,\n  addTokenListener,\n  removeTokenListener\n} from './internal-api';\nimport { Provider } from '@firebase/component';\nimport { PartialObserver } from '@firebase/util';\n\nimport { FirebaseService } from '@firebase/app-types/private';\nimport { getState, ListenerType } from './state';\n\nexport function factory(\n  app: FirebaseApp,\n  platformLoggerProvider: Provider<'platform-logger'>\n): FirebaseAppCheck & FirebaseService {\n  return {\n    app,\n    activate: (\n      siteKeyOrProvider: string | AppCheckProvider,\n      isTokenAutoRefreshEnabled?: boolean\n    ) => activate(app, siteKeyOrProvider, isTokenAutoRefreshEnabled),\n    setTokenAutoRefreshEnabled: (isTokenAutoRefreshEnabled: boolean) =>\n      setTokenAutoRefreshEnabled(app, isTokenAutoRefreshEnabled),\n    getToken: forceRefresh =>\n      getToken(app, platformLoggerProvider, forceRefresh),\n    onTokenChanged: (\n      onNextOrObserver:\n        | ((tokenResult: AppCheckTokenResult) => void)\n        | PartialObserver<AppCheckTokenResult>,\n      onError?: (error: Error) => void,\n      onCompletion?: () => void\n    ) =>\n      onTokenChanged(\n        app,\n        platformLoggerProvider,\n        /**\n         * This can still be an observer. Need to do this casting because\n         * according to Typescript: \"Implementation signatures of overloads\n         * are not externally visible\"\n         */\n        onNextOrObserver as (tokenResult: AppCheckTokenResult) => void,\n        onError,\n        onCompletion\n      ),\n    INTERNAL: {\n      delete: () => {\n        const { tokenObservers } = getState(app);\n        for (const tokenObserver of tokenObservers) {\n          removeTokenListener(app, tokenObserver.next);\n        }\n        return Promise.resolve();\n      }\n    }\n  };\n}\n\nexport function internalFactory(\n  app: FirebaseApp,\n  platformLoggerProvider: Provider<'platform-logger'>\n): FirebaseAppCheckInternal {\n  return {\n    getToken: forceRefresh =>\n      getTokenInternal(app, platformLoggerProvider, forceRefresh),\n    addTokenListener: listener =>\n      addTokenListener(\n        app,\n        platformLoggerProvider,\n        ListenerType.INTERNAL,\n        listener\n      ),\n    removeTokenListener: listener => removeTokenListener(app, listener)\n  };\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport firebase from '@firebase/app';\nimport { _FirebaseNamespace } from '@firebase/app-types/private';\nimport {\n  Component,\n  ComponentType,\n  InstantiationMode\n} from '@firebase/component';\nimport {\n  FirebaseAppCheck,\n  AppCheckComponentName\n} from '@firebase/app-check-types';\nimport { factory, internalFactory } from './factory';\nimport { initializeDebugMode } from './debug';\nimport { AppCheckInternalComponentName } from '@firebase/app-check-interop-types';\nimport { name, version } from '../package.json';\n\nconst APP_CHECK_NAME: AppCheckComponentName = 'appCheck';\nconst APP_CHECK_NAME_INTERNAL: AppCheckInternalComponentName =\n  'app-check-internal';\nfunction registerAppCheck(firebase: _FirebaseNamespace): void {\n  // The public interface\n  firebase.INTERNAL.registerComponent(\n    new Component(\n      APP_CHECK_NAME,\n      container => {\n        // getImmediate for FirebaseApp will always succeed\n        const app = container.getProvider('app').getImmediate();\n        const platformLoggerProvider = container.getProvider('platform-logger');\n        return factory(app, platformLoggerProvider);\n      },\n      ComponentType.PUBLIC\n    )\n      /**\n       * AppCheck can only be initialized by explicitly calling firebase.appCheck()\n       * We don't want firebase products that consume AppCheck to gate on AppCheck\n       * if the user doesn't intend them to, just because the AppCheck component\n       * is registered.\n       */\n      .setInstantiationMode(InstantiationMode.EXPLICIT)\n      /**\n       * Because all firebase products that depend on app-check depend on app-check-internal directly,\n       * we need to initialize app-check-internal after app-check is initialized to make it\n       * available to other firebase products.\n       */\n      .setInstanceCreatedCallback(\n        (container, _instanceIdentifier, _instance) => {\n          const appCheckInternalProvider = container.getProvider(\n            APP_CHECK_NAME_INTERNAL\n          );\n          appCheckInternalProvider.initialize();\n        }\n      )\n  );\n\n  // The internal interface used by other Firebase products\n  firebase.INTERNAL.registerComponent(\n    new Component(\n      APP_CHECK_NAME_INTERNAL,\n      container => {\n        // getImmediate for FirebaseApp will always succeed\n        const app = container.getProvider('app').getImmediate();\n        const platformLoggerProvider = container.getProvider('platform-logger');\n        return internalFactory(app, platformLoggerProvider);\n      },\n      ComponentType.PUBLIC\n    ).setInstantiationMode(InstantiationMode.EXPLICIT)\n  );\n\n  firebase.registerVersion(name, version);\n}\n\nregisterAppCheck(firebase as _FirebaseNamespace);\ninitializeDebugMode();\n\n/**\n * Define extension behavior of `registerAnalytics`\n */\ndeclare module '@firebase/app-types' {\n  interface FirebaseNamespace {\n    appCheck(app?: FirebaseApp): FirebaseAppCheck;\n  }\n  interface FirebaseApp {\n    appCheck(): FirebaseAppCheck;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}